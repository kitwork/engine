package main

import (
	"fmt"
	"io/ioutil"
	"regexp"
	"strconv"
	"strings"
)

// --- 1. CONFIGURATION ---

type Color struct{ R, G, B int }

func (c Color) String() string { return fmt.Sprintf("%d, %d, %d", c.R, c.G, c.B) }
func Hex(h string) Color {
	h = strings.TrimPrefix(h, "#")
	if len(h) == 3 {
		h = string([]byte{h[0], h[0], h[1], h[1], h[2], h[2]})
	}
	val, _ := strconv.ParseUint(h, 16, 32)
	return Color{int(val >> 16), int((val >> 8) & 0xFF), int(val & 0xFF)}
}

var (
	Colors = map[string]map[string]Color{
		"Primitives": {
			"white": Hex("#FFFFFF"), "black": Hex("#000000"), "gray": Hex("#808080"),
			"red": Hex("#FF0000"), "blue": Hex("#4242FF"), "kitwork": Hex("#f82244"),
		},
		"Semantic": {
			"primary": Hex("#4242FF"), "success": Hex("#02D842"), "danger": Hex("#FF4242"),
			"warning": Hex("#FF6824"), "info": Hex("#2288FF"), "ghost": Hex("#F8F8FF"),
		},
	}
	SpacingScale = []int{0, 2, 4, 8, 12, 16, 20, 24, 32, 40, 48, 64, 80, 100, 120, 160, 200, 240, 320, 400}
	TypoScale    = []int{10, 12, 14, 16, 18, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72}
	RoundedScale = []int{0, 2, 4, 8, 12, 16, 24, 32, 48, 9999}
	MediaQueries = map[string]string{
		"mobile": "@media (max-width: 600px)", "tablet": "@media (max-width: 900px)",
		"laptop": "@media (max-width: 1200px)", "desktop": "@media (min-width: 1280px)",
	}
)

// --- 2. GENERATORS ---

func main() {
	html, _ := ioutil.ReadFile("demo/view/work.html")
	framework := GenerateFullFramework()
	jit := GenerateJIT(string(html))

	_ = ioutil.WriteFile("demo/public/css/framework.css", []byte(framework), 0644)
	_ = ioutil.WriteFile("demo/public/css/jit.css", []byte(jit), 0644)

	fmt.Printf("Power Build Success! FW: %d | JIT: %d\n", len(framework), len(jit))
}

func GenerateFullFramework() string {
	var b strings.Builder
	b.WriteString("/* Kitwork Industrial Framework - Full Master Build */\n\n")

	b.WriteString(":root {\n")
	for group, colors := range Colors {
		fmt.Fprintf(&b, "\t/* %s */\n", group)
		for k, v := range colors {
			fmt.Fprintf(&b, "\t--color-%s-rgb: %s;\n", k, v.String())
		}
	}
	b.WriteString("}\n\n* { box-sizing: border-box; }\n\n")

	// 1. Spacing (Full master build)
	dirs := map[string][]string{"-top": {"top"}, "-bottom": {"bottom"}, "-left": {"left"}, "-right": {"right"}, "-x": {"left", "right"}, "-y": {"top", "bottom"}, "": {""}}
	for _, prop := range []string{"margin", "padding"} {
		for suffix, subProps := range dirs {
			for _, v := range SpacingScale {
				fmt.Fprintf(&b, ".%s%s-%d { ", prop, suffix, v)
				for _, sub := range subProps {
					if sub == "" {
						fmt.Fprintf(&b, "%s: %dpx; ", prop, v)
					} else {
						fmt.Fprintf(&b, "%s-%s: %dpx; ", prop, sub, v)
					}
				}
				b.WriteString("}\n")
			}
		}
	}

	// 2. Typography
	for _, v := range TypoScale {
		fmt.Fprintf(&b, ".text-%d { font-size: %dpx; }\n", v, v)
	}
	for k, v := range map[string]int{"light": 300, "normal": 400, "medium": 500, "bold": 700, "black": 900} {
		fmt.Fprintf(&b, ".font-%s { font-weight: %d; }\n", k, v)
	}
	for _, a := range []string{"left", "center", "right", "justify"} {
		fmt.Fprintf(&b, ".text-%s { text-align: %s; }\n", a, a)
	}
	for _, t := range []string{"uppercase", "lowercase", "capitalize"} {
		fmt.Fprintf(&b, ".text-%s { text-transform: %s; }\n", t, t)
	}

	// 3. Layout
	for _, d := range []string{"flex", "grid", "block", "inline-block", "none"} {
		fmt.Fprintf(&b, ".display-%s { display: %s; }\n", d, d)
	}
	b.WriteString(".flex-row { flex-direction: row; }\n.flex-column { flex-direction: column; }\n.flex-wrap { flex-wrap: wrap; }\n")
	for k, v := range map[string]string{"start": "flex-start", "end": "flex-end", "center": "center", "between": "space-between", "around": "space-around"} {
		fmt.Fprintf(&b, ".justify-%s { justify-content: %s; }\n", k, v)
	}
	for k, v := range map[string]string{"start": "flex-start", "end": "flex-end", "center": "center", "stretch": "stretch"} {
		fmt.Fprintf(&b, ".items-%s { align-items: %s; }\n", k, v)
	}
	for i := 1; i <= 12; i++ {
		fmt.Fprintf(&b, ".grid-columns-%d { grid-template-columns: repeat(%d, minmax(0, 1fr)); }\n", i, i)
	}
	for _, v := range SpacingScale {
		if v <= 80 {
			fmt.Fprintf(&b, ".gap-%d { gap: %dpx; }\n", v, v)
		}
	}

	// 4. Colors
	for _, group := range Colors {
		for name := range group {
			fmt.Fprintf(&b, ".text-%[1]s { color: rgb(var(--color-%[1]s-rgb)); }\n", name)
			fmt.Fprintf(&b, ".background-%[1]s { background-color: rgb(var(--color-%[1]s-rgb)); }\n", name)
			fmt.Fprintf(&b, ".border-%[1]s { border-color: rgb(var(--color-%[1]s-rgb)); border-style: solid; }\n", name)
		}
	}

	// 5. Decorations & Sizing
	b.WriteString(".container { width: 100%; margin-inline: auto; padding-inline: 1.5rem; }\n.width-full { width: 100%; }\n.height-full { height: 100%; }\n")
	for _, v := range RoundedScale {
		n := fmt.Sprintf("%d", v)
		if v == 9999 {
			n = "full"
		}
		fmt.Fprintf(&b, ".rounded-%s { border-radius: %dpx; }\n", n, v)
	}

	return b.String()
}

func GenerateJIT(html string) string {
	generated := make(map[string]bool)
	var b strings.Builder
	b.WriteString("/* JIT Dynamic Utilities */\n")

	re := regexp.MustCompile(`class="([^"]+)"`)
	matches := re.FindAllStringSubmatch(html, -1)
	for _, m := range matches {
		for _, class := range strings.Fields(m[1]) {
			if !generated[class] {
				if css := resolve(class); css != "" {
					b.WriteString(css)
					generated[class] = true
				}
			}
		}
	}
	return b.String()
}

func resolve(class string) string {
	sc, ps, gr, _, core := parse(class)
	prop := ""

	if strings.HasPrefix(core, "background-") {
		prop = "background-color: rgb(var(--color-" + strings.TrimPrefix(core, "background-") + "-rgb));"
	} else if strings.HasPrefix(core, "margin-top-") {
		prop = "margin-top: " + strings.TrimPrefix(core, "margin-top-") + "px;"
	}
	// ... (Dễ dàng mở rộng thêm Quy chuẩn JIT ở đây)

	if prop == "" {
		return ""
	}
	esc := strings.NewReplacer(":", "\\:", ".", "\\.", "/", "\\/").Replace(class)
	selector := "." + esc
	if gr {
		selector = ".group:hover " + selector
	} else if ps != "" {
		selector += ":" + ps
	}
	if sc != "def" {
		return fmt.Sprintf("\n%s {\n\t%s { %s }\n}\n", MediaQueries[sc], selector, prop)
	}
	return fmt.Sprintf("\t%s { %s }\n", selector, prop)
}

func parse(f string) (s, p string, g, n bool, c string) {
	c = f
	s = "def"
	for k := range MediaQueries {
		if strings.HasPrefix(c, k+":") {
			s = k
			c = strings.TrimPrefix(c, k+":")
			break
		}
	}
	if strings.HasPrefix(c, "group-hover:") {
		g = true
		c = strings.TrimPrefix(c, "group-hover:")
	}
	for _, x := range []string{"hover", "focus"} {
		if strings.HasPrefix(c, x+":") {
			p = x
			c = strings.TrimPrefix(c, x+":")
			break
		}
	}
	if strings.HasPrefix(c, "-") {
		n = true
		c = strings.TrimPrefix(c, "-")
	}
	return
}
